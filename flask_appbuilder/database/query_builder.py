"""
Advanced Visual Query Builder for Apache AGE

Provides drag-and-drop query construction, templates, and natural language processing
for OpenCypher query generation with real-time validation and optimization.
"""

import re
import json
import logging
from datetime import datetime
from typing import Dict, List, Optional, Any, Tuple, Union
from dataclasses import dataclass, asdict
from enum import Enum
import sqlalchemy as sa
from sqlalchemy import text

from .graph_manager import GraphDatabaseManager, get_graph_manager

logger = logging.getLogger(__name__)


class QueryComponentType(Enum):
	"""Types of query components"""
	MATCH = "match"
	WHERE = "where" 
	RETURN = "return"
	CREATE = "create"
	SET = "set"
	DELETE = "delete"
	WITH = "with"
	ORDER_BY = "order_by"
	LIMIT = "limit"
	SKIP = "skip"


class NodePattern(Enum):
	"""Node pattern types"""
	VARIABLE = "variable"
	LABELED = "labeled"
	PROPERTY = "property"
	ANONYMOUS = "anonymous"


class RelationshipPattern(Enum):
	"""Relationship pattern types"""
	OUTGOING = "outgoing"
	INCOMING = "incoming"
	UNDIRECTED = "undirected"
	VARIABLE_LENGTH = "variable_length"


@dataclass
class QueryComponent:
	"""
	Represents a single query component in the visual builder
	
	Attributes:
		id: Unique component identifier
		type: Component type (MATCH, WHERE, etc.)
		position: Visual position in builder
		config: Component configuration
		connections: Connected component IDs
		validation: Validation status and messages
	"""
	
	id: str
	type: QueryComponentType
	position: Dict[str, float]
	config: Dict[str, Any]
	connections: List[str] = None
	validation: Dict[str, Any] = None
	
	def __post_init__(self):
		if self.connections is None:
			self.connections = []
		if self.validation is None:
			self.validation = {"valid": True, "messages": []}
	
	def to_dict(self) -> Dict[str, Any]:
		"""Convert to dictionary for serialization"""
		return {
			"id": self.id,
			"type": self.type.value,
			"position": self.position,
			"config": self.config,
			"connections": self.connections,
			"validation": self.validation
		}


@dataclass  
class QueryTemplate:
	"""
	Pre-built query template for common operations
	
	Attributes:
		id: Template identifier
		name: Human-readable name
		description: Template description
		category: Template category
		cypher: Base Cypher query
		parameters: Template parameters
		components: Visual components for builder
	"""
	
	id: str
	name: str
	description: str
	category: str
	cypher: str
	parameters: List[Dict[str, Any]]
	components: List[QueryComponent]
	
	def to_dict(self) -> Dict[str, Any]:
		"""Convert to dictionary for serialization"""
		return {
			"id": self.id,
			"name": self.name,
			"description": self.description,
			"category": self.category,
			"cypher": self.cypher,
			"parameters": self.parameters,
			"components": [comp.to_dict() for comp in self.components]
		}


class CypherQueryValidator:
	"""
	Validates and optimizes Cypher queries
	
	Provides syntax validation, performance analysis, and optimization suggestions
	for OpenCypher queries generated by the visual builder.
	"""
	
	def __init__(self, graph_manager: GraphDatabaseManager = None):
		self.graph_manager = graph_manager or get_graph_manager()
		
		# Common query patterns for validation
		self.patterns = {
			"node_pattern": r"\([a-zA-Z_][a-zA-Z0-9_]*(?::[a-zA-Z_][a-zA-Z0-9_]*)*(?:\s*\{[^}]*\})?\)",
			"relationship_pattern": r"-\[[a-zA-Z_][a-zA-Z0-9_]*(?::[a-zA-Z_][a-zA-Z0-9_]*)*(?:\s*\{[^}]*\})?\]->?",
			"variable_pattern": r"[a-zA-Z_][a-zA-Z0-9_]*",
			"property_pattern": r"[a-zA-Z_][a-zA-Z0-9_]*\.[a-zA-Z_][a-zA-Z0-9_]*"
		}
	
	def validate_query(self, query: str) -> Dict[str, Any]:
		"""
		Validate Cypher query syntax and structure
		
		Args:
			query: Cypher query string
			
		Returns:
			Validation result with errors and warnings
		"""
		try:
			validation_result = {
				"valid": True,
				"errors": [],
				"warnings": [],
				"suggestions": [],
				"complexity_score": 0
			}
			
			# Basic syntax validation
			syntax_errors = self._validate_syntax(query)
			validation_result["errors"].extend(syntax_errors)
			
			# Performance warnings
			performance_warnings = self._analyze_performance(query)
			validation_result["warnings"].extend(performance_warnings)
			
			# Optimization suggestions
			optimization_suggestions = self._suggest_optimizations(query)
			validation_result["suggestions"].extend(optimization_suggestions)
			
			# Calculate complexity score
			validation_result["complexity_score"] = self._calculate_complexity(query)
			
			# Set overall validity
			validation_result["valid"] = len(validation_result["errors"]) == 0
			
			return validation_result
			
		except Exception as e:
			logger.error(f"Query validation failed: {e}")
			return {
				"valid": False,
				"errors": [f"Validation error: {str(e)}"],
				"warnings": [],
				"suggestions": [],
				"complexity_score": 0
			}
	
	def _validate_syntax(self, query: str) -> List[str]:
		"""Validate basic Cypher syntax"""
		errors = []
		
		# Check for balanced parentheses and brackets
		if not self._check_balanced_delimiters(query):
			errors.append("Unbalanced parentheses or brackets")
		
		# Check for required clauses
		query_upper = query.upper()
		if "MATCH" not in query_upper and "CREATE" not in query_upper:
			errors.append("Query must contain MATCH or CREATE clause")
		
		if "RETURN" not in query_upper and "DELETE" not in query_upper:
			errors.append("Query must contain RETURN or DELETE clause")
		
		# Check for invalid characters or patterns
		if re.search(r'[^\w\s\(\)\[\]\{\}\.,:;\-=<>!"\']', query):
			errors.append("Query contains invalid characters")
		
		return errors
	
	def _check_balanced_delimiters(self, query: str) -> bool:
		"""Check if parentheses and brackets are balanced"""
		stack = []
		pairs = {"(": ")", "[": "]", "{": "}"}
		
		for char in query:
			if char in pairs:
				stack.append(char)
			elif char in pairs.values():
				if not stack or pairs.get(stack.pop()) != char:
					return False
		
		return len(stack) == 0
	
	def _analyze_performance(self, query: str) -> List[str]:
		"""Analyze query for performance issues"""
		warnings = []
		
		# Check for cartesian products
		if re.search(r'MATCH\s+.*,\s*MATCH', query, re.IGNORECASE):
			warnings.append("Potential cartesian product detected - consider using relationships")
		
		# Check for missing WHERE clauses with MATCH
		match_count = len(re.findall(r'MATCH', query, re.IGNORECASE))
		where_count = len(re.findall(r'WHERE', query, re.IGNORECASE))
		
		if match_count > where_count:
			warnings.append("Consider adding WHERE clauses to filter results early")
		
		# Check for SELECT * equivalent
		if re.search(r'RETURN\s+\*', query, re.IGNORECASE):
			warnings.append("Returning all properties may impact performance")
		
		# Check for lack of LIMIT
		if "LIMIT" not in query.upper() and "MATCH" in query.upper():
			warnings.append("Consider adding LIMIT clause for large datasets")
		
		return warnings
	
	def _suggest_optimizations(self, query: str) -> List[str]:
		"""Suggest query optimizations"""
		suggestions = []
		
		# Suggest index usage
		if re.search(r'WHERE\s+\w+\.\w+\s*=', query, re.IGNORECASE):
			suggestions.append("Consider creating indexes on frequently queried properties")
		
		# Suggest WITH clause for complex queries
		return_match = re.search(r'RETURN.*MATCH', query, re.IGNORECASE | re.DOTALL)
		if return_match:
			suggestions.append("Consider using WITH clause to improve query readability")
		
		# Suggest property access optimization
		prop_count = len(re.findall(r'\w+\.\w+', query))
		if prop_count > 5:
			suggestions.append("Consider reducing property accesses or using WITH clause")
		
		return suggestions
	
	def _calculate_complexity(self, query: str) -> int:
		"""Calculate query complexity score"""
		score = 0
		
		# Basic clause complexity
		clauses = ["MATCH", "WHERE", "WITH", "RETURN", "CREATE", "SET", "DELETE"]
		for clause in clauses:
			score += len(re.findall(clause, query, re.IGNORECASE)) * 2
		
		# Path complexity
		score += len(re.findall(r'-\[.*?\]-', query)) * 3
		
		# Property access complexity  
		score += len(re.findall(r'\w+\.\w+', query))
		
		# Function complexity
		score += len(re.findall(r'\w+\([^)]*\)', query)) * 2
		
		return min(score, 100)  # Cap at 100


class VisualQueryBuilder:
	"""
	Visual drag-and-drop query builder for OpenCypher
	
	Enables non-technical users to construct complex graph queries through
	an intuitive visual interface with real-time validation and preview.
	"""
	
	def __init__(self, graph_manager: GraphDatabaseManager = None):
		self.graph_manager = graph_manager or get_graph_manager()
		self.validator = CypherQueryValidator(self.graph_manager)
		self.templates = self._load_query_templates()
	
	def _load_query_templates(self) -> List[QueryTemplate]:
		"""Load pre-built query templates"""
		templates = [
			QueryTemplate(
				id="find_all_nodes",
				name="Find All Nodes",
				description="Retrieve all nodes in the graph with optional filtering",
				category="Basic",
				cypher="MATCH (n) WHERE $filter RETURN n LIMIT $limit",
				parameters=[
					{"name": "filter", "type": "string", "default": "true", "description": "Filter condition"},
					{"name": "limit", "type": "integer", "default": 25, "description": "Result limit"}
				],
				components=[
					QueryComponent(
						id="match_1",
						type=QueryComponentType.MATCH,
						position={"x": 100, "y": 100},
						config={
							"pattern": "(n)",
							"variable": "n",
							"label": "",
							"properties": {}
						}
					),
					QueryComponent(
						id="return_1", 
						type=QueryComponentType.RETURN,
						position={"x": 300, "y": 100},
						config={
							"expressions": ["n"],
							"distinct": False
						},
						connections=["match_1"]
					)
				]
			),
			
			QueryTemplate(
				id="shortest_path",
				name="Shortest Path",
				description="Find shortest path between two nodes",
				category="Path Finding",
				cypher="MATCH path = shortestPath((start)-[*]-(end)) WHERE id(start) = $start_id AND id(end) = $end_id RETURN path",
				parameters=[
					{"name": "start_id", "type": "string", "description": "Starting node ID"},
					{"name": "end_id", "type": "string", "description": "Ending node ID"}
				],
				components=[
					QueryComponent(
						id="match_path",
						type=QueryComponentType.MATCH,
						position={"x": 100, "y": 100},
						config={
							"pattern": "path = shortestPath((start)-[*]-(end))",
							"path_variable": "path",
							"start_node": "start",
							"end_node": "end"
						}
					),
					QueryComponent(
						id="where_ids",
						type=QueryComponentType.WHERE,
						position={"x": 100, "y": 200},
						config={
							"conditions": [
								"id(start) = $start_id",
								"id(end) = $end_id"
							],
							"operator": "AND"
						},
						connections=["match_path"]
					),
					QueryComponent(
						id="return_path",
						type=QueryComponentType.RETURN,
						position={"x": 300, "y": 150},
						config={
							"expressions": ["path"]
						},
						connections=["where_ids"]
					)
				]
			),
			
			QueryTemplate(
				id="node_neighbors",
				name="Node Neighbors",
				description="Find neighbors of a specific node",
				category="Traversal",
				cypher="MATCH (center)-[r]-(neighbor) WHERE id(center) = $node_id RETURN center, r, neighbor LIMIT $limit",
				parameters=[
					{"name": "node_id", "type": "string", "description": "Center node ID"},
					{"name": "limit", "type": "integer", "default": 50, "description": "Result limit"}
				],
				components=[
					QueryComponent(
						id="match_neighbors",
						type=QueryComponentType.MATCH,
						position={"x": 100, "y": 100},
						config={
							"pattern": "(center)-[r]-(neighbor)",
							"center_variable": "center",
							"relationship_variable": "r", 
							"neighbor_variable": "neighbor",
							"direction": "both"
						}
					),
					QueryComponent(
						id="where_center",
						type=QueryComponentType.WHERE,
						position={"x": 100, "y": 200},
						config={
							"conditions": ["id(center) = $node_id"]
						},
						connections=["match_neighbors"]
					),
					QueryComponent(
						id="return_all",
						type=QueryComponentType.RETURN,
						position={"x": 300, "y": 150},
						config={
							"expressions": ["center", "r", "neighbor"]
						},
						connections=["where_center"]
					),
					QueryComponent(
						id="limit_results",
						type=QueryComponentType.LIMIT,
						position={"x": 300, "y": 250},
						config={
							"count": "$limit"
						},
						connections=["return_all"]
					)
				]
			),
			
			QueryTemplate(
				id="property_aggregation",
				name="Property Aggregation",
				description="Aggregate node properties by label",
				category="Analytics",
				cypher="MATCH (n) WHERE n.$property IS NOT NULL RETURN labels(n) as label, count(n) as node_count, avg(n.$property) as avg_value, min(n.$property) as min_value, max(n.$property) as max_value ORDER BY node_count DESC",
				parameters=[
					{"name": "property", "type": "string", "description": "Property to aggregate"}
				],
				components=[
					QueryComponent(
						id="match_nodes",
						type=QueryComponentType.MATCH,
						position={"x": 100, "y": 100},
						config={
							"pattern": "(n)",
							"variable": "n"
						}
					),
					QueryComponent(
						id="where_property",
						type=QueryComponentType.WHERE,
						position={"x": 100, "y": 200},
						config={
							"conditions": ["n.$property IS NOT NULL"]
						},
						connections=["match_nodes"]
					),
					QueryComponent(
						id="return_aggregates",
						type=QueryComponentType.RETURN,
						position={"x": 300, "y": 150},
						config={
							"expressions": [
								"labels(n) as label",
								"count(n) as node_count",
								"avg(n.$property) as avg_value",
								"min(n.$property) as min_value", 
								"max(n.$property) as max_value"
							]
						},
						connections=["where_property"]
					),
					QueryComponent(
						id="order_results",
						type=QueryComponentType.ORDER_BY,
						position={"x": 300, "y": 250},
						config={
							"expressions": ["node_count DESC"]
						},
						connections=["return_aggregates"]
					)
				]
			)
		]
		
		return templates
	
	def get_templates(self, category: str = None) -> List[Dict[str, Any]]:
		"""Get query templates, optionally filtered by category"""
		if category:
			filtered_templates = [t for t in self.templates if t.category == category]
			return [t.to_dict() for t in filtered_templates]
		
		return [t.to_dict() for t in self.templates]
	
	def get_template_categories(self) -> List[str]:
		"""Get list of template categories"""
		categories = list(set(t.category for t in self.templates))
		return sorted(categories)
	
	def build_query_from_components(self, components: List[Dict[str, Any]]) -> Dict[str, Any]:
		"""
		Build Cypher query from visual components
		
		Args:
			components: List of query component dictionaries
			
		Returns:
			Dictionary with generated query and metadata
		"""
		try:
			# Convert dictionaries to QueryComponent objects
			query_components = []
			for comp_data in components:
				component = QueryComponent(
					id=comp_data["id"],
					type=QueryComponentType(comp_data["type"]),
					position=comp_data["position"],
					config=comp_data["config"],
					connections=comp_data.get("connections", []),
					validation=comp_data.get("validation", {"valid": True, "messages": []})
				)
				query_components.append(component)
			
			# Sort components by execution order
			ordered_components = self._order_components(query_components)
			
			# Generate Cypher clauses
			cypher_clauses = []
			variables_defined = set()
			
			for component in ordered_components:
				clause = self._generate_clause(component, variables_defined)
				if clause:
					cypher_clauses.append(clause)
			
			# Combine clauses into complete query
			cypher_query = "\n".join(cypher_clauses)
			
			# Validate generated query
			validation_result = self.validator.validate_query(cypher_query)
			
			return {
				"success": True,
				"query": cypher_query,
				"validation": validation_result,
				"component_count": len(query_components),
				"complexity_score": validation_result["complexity_score"]
			}
			
		except Exception as e:
			logger.error(f"Query building failed: {e}")
			return {
				"success": False,
				"error": str(e),
				"query": "",
				"validation": {"valid": False, "errors": [str(e)]}
			}
	
	def _order_components(self, components: List[QueryComponent]) -> List[QueryComponent]:
		"""Order components by logical execution sequence"""
		# Define component precedence
		precedence = {
			QueryComponentType.MATCH: 1,
			QueryComponentType.CREATE: 1,
			QueryComponentType.WHERE: 2,
			QueryComponentType.WITH: 3,
			QueryComponentType.SET: 4,
			QueryComponentType.DELETE: 4,
			QueryComponentType.RETURN: 5,
			QueryComponentType.ORDER_BY: 6,
			QueryComponentType.SKIP: 7,
			QueryComponentType.LIMIT: 8
		}
		
		return sorted(components, key=lambda c: precedence.get(c.type, 9))
	
	def _generate_clause(self, component: QueryComponent, variables_defined: set) -> str:
		"""Generate Cypher clause from component"""
		try:
			if component.type == QueryComponentType.MATCH:
				return self._generate_match_clause(component, variables_defined)
			elif component.type == QueryComponentType.WHERE:
				return self._generate_where_clause(component)
			elif component.type == QueryComponentType.RETURN:
				return self._generate_return_clause(component)
			elif component.type == QueryComponentType.CREATE:
				return self._generate_create_clause(component, variables_defined)
			elif component.type == QueryComponentType.SET:
				return self._generate_set_clause(component)
			elif component.type == QueryComponentType.DELETE:
				return self._generate_delete_clause(component)
			elif component.type == QueryComponentType.WITH:
				return self._generate_with_clause(component)
			elif component.type == QueryComponentType.ORDER_BY:
				return self._generate_order_by_clause(component)
			elif component.type == QueryComponentType.LIMIT:
				return self._generate_limit_clause(component)
			elif component.type == QueryComponentType.SKIP:
				return self._generate_skip_clause(component)
			
			return ""
			
		except Exception as e:
			logger.error(f"Clause generation failed for {component.id}: {e}")
			return f"-- Error generating clause for {component.id}"
	
	def _generate_match_clause(self, component: QueryComponent, variables_defined: set) -> str:
		"""Generate MATCH clause"""
		config = component.config
		pattern = config.get("pattern", "(n)")
		
		# Track defined variables
		variables = re.findall(r'\b([a-zA-Z_][a-zA-Z0-9_]*)\b', pattern)
		variables_defined.update(variables)
		
		return f"MATCH {pattern}"
	
	def _generate_where_clause(self, component: QueryComponent) -> str:
		"""Generate WHERE clause"""
		config = component.config
		conditions = config.get("conditions", [])
		operator = config.get("operator", "AND")
		
		if not conditions:
			return ""
		
		condition_str = f" {operator} ".join(conditions)
		return f"WHERE {condition_str}"
	
	def _generate_return_clause(self, component: QueryComponent) -> str:
		"""Generate RETURN clause"""
		config = component.config
		expressions = config.get("expressions", ["*"])
		distinct = config.get("distinct", False)
		
		distinct_str = "DISTINCT " if distinct else ""
		expression_str = ", ".join(expressions)
		
		return f"RETURN {distinct_str}{expression_str}"
	
	def _generate_create_clause(self, component: QueryComponent, variables_defined: set) -> str:
		"""Generate CREATE clause"""
		config = component.config
		pattern = config.get("pattern", "(n)")
		
		# Track defined variables
		variables = re.findall(r'\b([a-zA-Z_][a-zA-Z0-9_]*)\b', pattern)
		variables_defined.update(variables)
		
		return f"CREATE {pattern}"
	
	def _generate_set_clause(self, component: QueryComponent) -> str:
		"""Generate SET clause"""
		config = component.config
		assignments = config.get("assignments", [])
		
		if not assignments:
			return ""
		
		assignment_str = ", ".join(assignments)
		return f"SET {assignment_str}"
	
	def _generate_delete_clause(self, component: QueryComponent) -> str:
		"""Generate DELETE clause"""
		config = component.config
		variables = config.get("variables", [])
		detach = config.get("detach", False)
		
		if not variables:
			return ""
		
		delete_type = "DETACH DELETE" if detach else "DELETE"
		variable_str = ", ".join(variables)
		
		return f"{delete_type} {variable_str}"
	
	def _generate_with_clause(self, component: QueryComponent) -> str:
		"""Generate WITH clause"""
		config = component.config
		expressions = config.get("expressions", [])
		distinct = config.get("distinct", False)
		
		if not expressions:
			return ""
		
		distinct_str = "DISTINCT " if distinct else ""
		expression_str = ", ".join(expressions)
		
		return f"WITH {distinct_str}{expression_str}"
	
	def _generate_order_by_clause(self, component: QueryComponent) -> str:
		"""Generate ORDER BY clause"""
		config = component.config
		expressions = config.get("expressions", [])
		
		if not expressions:
			return ""
		
		expression_str = ", ".join(expressions)
		return f"ORDER BY {expression_str}"
	
	def _generate_limit_clause(self, component: QueryComponent) -> str:
		"""Generate LIMIT clause"""
		config = component.config
		count = config.get("count", "25")
		
		return f"LIMIT {count}"
	
	def _generate_skip_clause(self, component: QueryComponent) -> str:
		"""Generate SKIP clause"""
		config = component.config
		count = config.get("count", "0")
		
		return f"SKIP {count}"
	
	def optimize_query(self, query: str) -> Dict[str, Any]:
		"""
		Optimize Cypher query for better performance
		
		Args:
			query: Original Cypher query
			
		Returns:
			Dictionary with optimized query and improvements
		"""
		try:
			optimized_query = query
			improvements = []
			
			# Add LIMIT if missing for MATCH queries
			if "MATCH" in query.upper() and "LIMIT" not in query.upper():
				optimized_query += " LIMIT 1000"
				improvements.append("Added LIMIT clause to prevent large result sets")
			
			# Optimize property access patterns
			property_pattern = r'(\w+)\.(\w+)\s*=\s*([^,\s]+)'
			matches = re.findall(property_pattern, query)
			
			if matches:
				suggestions = []
				for var, prop, value in matches:
					suggestions.append(f"Consider indexing {var}.{prop} for better performance")
				improvements.extend(suggestions)
			
			# Suggest WITH clause for complex queries
			if query.count("MATCH") > 1 and "WITH" not in query.upper():
				improvements.append("Consider using WITH clause to reduce intermediate results")
			
			return {
				"success": True,
				"original_query": query,
				"optimized_query": optimized_query,
				"improvements": improvements,
				"optimization_applied": len(improvements) > 0
			}
			
		except Exception as e:
			logger.error(f"Query optimization failed: {e}")
			return {
				"success": False,
				"error": str(e),
				"original_query": query,
				"optimized_query": query,
				"improvements": []
			}
	
	def natural_language_to_cypher(self, natural_query: str) -> Dict[str, Any]:
		"""
		Convert natural language query to Cypher (basic implementation)
		
		Args:
			natural_query: Natural language description
			
		Returns:
			Dictionary with generated Cypher query
		"""
		try:
			# Simple pattern matching for common queries
			natural_lower = natural_query.lower()
			
			# Find all nodes
			if any(phrase in natural_lower for phrase in ["find all", "show all", "get all"]):
				if "node" in natural_lower:
					return {
						"success": True,
						"cypher": "MATCH (n) RETURN n LIMIT 25",
						"confidence": 0.8,
						"description": "Find all nodes with limit"
					}
			
			# Find specific nodes
			if "find" in natural_lower and "where" in natural_lower:
				return {
					"success": True,
					"cypher": "MATCH (n) WHERE n.property = 'value' RETURN n",
					"confidence": 0.6,
					"description": "Find nodes with specific property (template)"
				}
			
			# Shortest path queries
			if any(phrase in natural_lower for phrase in ["shortest path", "path between"]):
				return {
					"success": True,
					"cypher": "MATCH path = shortestPath((start)-[*]-(end)) WHERE id(start) = $start_id AND id(end) = $end_id RETURN path",
					"confidence": 0.9,
					"description": "Find shortest path between nodes"
				}
			
			# Neighbors/connected nodes
			if any(phrase in natural_lower for phrase in ["neighbor", "connected", "related"]):
				return {
					"success": True,
					"cypher": "MATCH (center)-[r]-(neighbor) WHERE id(center) = $node_id RETURN center, r, neighbor",
					"confidence": 0.7,
					"description": "Find neighbors of a node"
				}
			
			return {
				"success": False,
				"error": "Could not interpret natural language query",
				"cypher": "",
				"confidence": 0,
				"suggestions": [
					"Try: 'Find all nodes'",
					"Try: 'Find shortest path between nodes'", 
					"Try: 'Show neighbors of node'"
				]
			}
			
		except Exception as e:
			logger.error(f"Natural language processing failed: {e}")
			return {
				"success": False,
				"error": str(e),
				"cypher": "",
				"confidence": 0
			}


# Global query builder instance
_query_builder = None


def get_query_builder(graph_manager: GraphDatabaseManager = None) -> VisualQueryBuilder:
	"""Get or create the global query builder instance"""
	global _query_builder
	if _query_builder is None:
		_query_builder = VisualQueryBuilder(graph_manager)
	return _query_builder