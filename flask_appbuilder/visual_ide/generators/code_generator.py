"""
Visual Code Generator for Visual IDE.

Generates production-ready Flask-AppBuilder code from visual view definitions
and component configurations.
"""

import os
import logging
from typing import Dict, List, Optional, Any, Set
from pathlib import Path
from jinja2 import Environment, BaseLoader, Template
from dataclasses import dataclass

from ..models.project_model import (
    IDEProject, ViewDefinition, ViewType, ComponentConfig, ComponentType
)
from ..components.component_library import ComponentLibrary

logger = logging.getLogger(__name__)


@dataclass
class GeneratedFile:
    """Represents a generated code file."""
    path: str
    content: str
    file_type: str  # 'view', 'model', 'template', 'config', 'static'
    language: str  # 'python', 'html', 'css', 'javascript'


class CodeTemplates:
    """Collection of code generation templates."""
    
    VIEW_TEMPLATE = """
from flask import render_template, redirect, url_for, request, flash
from flask_appbuilder import ModelView, BaseView, has_access
from flask_appbuilder.models.sqla.interface import SQLAInterface
from flask_appbuilder.security.decorators import protect
from flask_appbuilder.widgets import ListWidget, ShowWidget
from {{ app_name }}.models import {{ model_name }}

{% if imports %}
# Additional imports
{% for import_stmt in imports %}
{{ import_stmt }}
{% endfor %}
{% endif %}


class {{ view_class_name }}({{ base_class }}):
    {% if model_name %}
    datamodel = SQLAInterface({{ model_name }})
    {% endif %}
    
    {% if base_permissions %}
    base_permissions = {{ base_permissions }}
    {% endif %}
    
    {% if list_columns %}
    list_columns = {{ list_columns }}
    {% endif %}
    
    {% if show_columns %}
    show_columns = {{ show_columns }}
    {% endif %}
    
    {% if add_columns %}
    add_columns = {{ add_columns }}
    {% endif %}
    
    {% if edit_columns %}
    edit_columns = {{ edit_columns }}
    {% endif %}
    
    {% if search_columns %}
    search_columns = {{ search_columns }}
    {% endif %}
    
    {% if custom_methods %}
    # Custom methods
    {% for method_name, method_code in custom_methods.items() %}
    def {{ method_name }}(self):
        \"\"\"Auto-generated custom method.\"\"\"
{{ method_code | indent(8, True) }}
    {% endfor %}
    {% endif %}
    
    {% if view_type == 'MasterDetailView' %}
    # Master-Detail View Configuration
    related_views = {{ related_views if related_views else '[]' }}
    {% endif %}
    
    {% if security_config %}
    # Security Configuration
    {% if security_config.required_permissions %}
    @has_access
    def list(self):
        # Check permissions for list view
        return super().list()
    {% endif %}
    {% endif %}
"""

    MODEL_TEMPLATE = """
from flask_appbuilder import Model
from sqlalchemy import Column, Integer, String, Text, DateTime, Boolean, ForeignKey
from sqlalchemy.orm import relationship
from datetime import datetime

{% if imports %}
# Additional imports
{% for import_stmt in imports %}
{{ import_stmt }}
{% endfor %}
{% endif %}


class {{ model_class_name }}(Model):
    \"\"\"
    Auto-generated model for {{ model_name }}.
    Generated by Flask-AppBuilder Visual IDE.
    \"\"\"
    
    __tablename__ = '{{ table_name }}'
    
    # Primary key
    id = Column(Integer, primary_key=True)
    
    {% for field in fields %}
    # {{ field.description if field.description else field.name }}
    {{ field.name }} = Column({{ field.column_type }}{% if field.constraints %}, {{ field.constraints }}{% endif %})
    {% endfor %}
    
    {% if relationships %}
    # Relationships
    {% for rel in relationships %}
    {{ rel.name }} = relationship('{{ rel.target_model }}'{% if rel.back_populates %}, back_populates='{{ rel.back_populates }}'{% endif %})
    {% endfor %}
    {% endif %}
    
    # Audit fields
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    def __repr__(self):
        return f'<{{ model_class_name }} {self.id}>'
    
    def __str__(self):
        {% if str_repr_field %}
        return str(self.{{ str_repr_field }})
        {% else %}
        return f'{{ model_class_name }} {self.id}'
        {% endif %}
"""

    HTML_TEMPLATE = """
{% raw %}
{% extends "appbuilder/base.html" %}

{% block title %}{{ view_title }}{% endblock %}

{% block head_css %}
    {{ super() }}
    {% if custom_css %}
    <style>
{{ custom_css }}
    </style>
    {% endif %}
{% endblock %}

{% block content %}
<div class="container-fluid">
    {% if view_type == 'custom' %}
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <h3>{{ view_title }}</h3>
                </div>
                <div class="card-body">
                    {{ component_html | safe }}
                </div>
            </div>
        </div>
    </div>
    {% else %}
    {{ component_html | safe }}
    {% endif %}
</div>
{% endblock %}

{% block tail_js %}
    {{ super() }}
    {% if custom_js %}
    <script>
{{ custom_js }}
    </script>
    {% endif %}
{% endblock %}
{% endraw %}
"""

    INIT_TEMPLATE = """
from flask import Flask
from flask_appbuilder import AppBuilder, SQLA
from flask_appbuilder.menu import Menu

# Import views
{% for view_import in view_imports %}
{{ view_import }}
{% endfor %}

# Import models
{% for model_import in model_imports %}
{{ model_import }}
{% endfor %}

app = Flask(__name__)
app.config.from_object('config')
db = SQLA(app)
appbuilder = AppBuilder(app, db.session)

# Register views
{% for view_registration in view_registrations %}
{{ view_registration }}
{% endfor %}

from app import views
"""

    CONFIG_TEMPLATE = """
import os
from flask_appbuilder.security.manager import AUTH_OAUTH, AUTH_OID, AUTH_DB, AUTH_LDAP, AUTH_REMOTE_USER

# Flask settings
SECRET_KEY = '{{ secret_key }}'
WTF_CSRF_ENABLED = True

# Database settings
SQLALCHEMY_DATABASE_URI = '{{ database_uri }}'
SQLALCHEMY_TRACK_MODIFICATIONS = False

# Flask-AppBuilder settings
APP_NAME = "{{ app_name }}"
APP_THEME = "{{ theme if theme else 'bootstrap-theme.css' }}"
APP_ICON = "{{ app_icon if app_icon else 'static/img/logo.jpg' }}"

# Security settings
AUTH_TYPE = {{ auth_type if auth_type else 'AUTH_DB' }}
AUTH_ROLE_ADMIN = '{{ admin_role if admin_role else "Admin" }}'
AUTH_ROLE_PUBLIC = '{{ public_role if public_role else "Public" }}'

# Upload settings
UPLOAD_FOLDER = os.path.join(os.path.dirname(__file__), 'app/static/uploads/')
IMG_UPLOAD_FOLDER = os.path.join(UPLOAD_FOLDER, 'images/')
IMG_UPLOAD_URL = '/static/uploads/images/'

# Logging
LOGFILE = 'app.log'
LOGLEVEL = {{ log_level if log_level else 'INFO' }}

{% if additional_config %}
# Additional configuration
{% for key, value in additional_config.items() %}
{{ key }} = {{ value | repr }}
{% endfor %}
{% endif %}
"""


class VisualCodeGenerator:
    """
    Generates Flask-AppBuilder code from visual definitions.
    
    Takes view definitions created in the visual IDE and generates
    production-ready Python code, templates, and configuration files.
    """
    
    def __init__(self, output_path: Path, component_library: Optional[ComponentLibrary] = None):
        self.output_path = Path(output_path)
        self.component_library = component_library
        self.templates = CodeTemplates()
        self.jinja_env = Environment(loader=BaseLoader())
        self.generated_files: Dict[str, GeneratedFile] = {}
        
        # Create output directory structure
        self._setup_output_directories()
        
        logger.info(f"Code generator initialized with output path: {output_path}")
    
    def _setup_output_directories(self):
        """Create the output directory structure."""
        directories = [
            'views',
            'models', 
            'templates',
            'static/css',
            'static/js',
            'static/img',
            'static/uploads'
        ]
        
        for directory in directories:
            (self.output_path / directory).mkdir(parents=True, exist_ok=True)
    
    def generate_view_code(self, view_definition: ViewDefinition) -> Dict[str, str]:
        """
        Generate code for a single view definition.
        
        Args:
            view_definition: View to generate code for
            
        Returns:
            Dictionary mapping file paths to generated code
        """
        generated_files = {}
        
        try:
            # Generate Python view class
            view_code = self._generate_view_class(view_definition)
            view_file_path = f"views/{view_definition.name.lower()}_view.py"
            generated_files[view_file_path] = view_code
            
            # Generate HTML template if needed
            if self._requires_custom_template(view_definition):
                template_code = self._generate_html_template(view_definition)
                template_file_path = f"templates/{view_definition.name.lower()}.html"
                generated_files[template_file_path] = template_code
            
            # Generate CSS if custom styles exist
            css_code = self._generate_css_styles(view_definition)
            if css_code:
                css_file_path = f"static/css/{view_definition.name.lower()}.css"
                generated_files[css_file_path] = css_code
            
            # Generate JavaScript if needed
            js_code = self._generate_javascript(view_definition)
            if js_code:
                js_file_path = f"static/js/{view_definition.name.lower()}.js"
                generated_files[js_file_path] = js_code
            
            # Store generated files
            for path, content in generated_files.items():
                self.generated_files[path] = GeneratedFile(
                    path=path,
                    content=content,
                    file_type=self._determine_file_type(path),
                    language=self._determine_language(path)
                )
            
            logger.info(f"Generated {len(generated_files)} files for view: {view_definition.name}")
            return generated_files
            
        except Exception as e:
            logger.error(f"Failed to generate view code for {view_definition.name}: {e}")
            raise
    
    def _generate_view_class(self, view_definition: ViewDefinition) -> str:
        """Generate the Python view class code."""
        template = Template(self.templates.VIEW_TEMPLATE)
        
        # Determine base class
        base_class_map = {
            ViewType.MODEL_VIEW: "ModelView",
            ViewType.BASE_VIEW: "BaseView", 
            ViewType.MASTER_DETAIL_VIEW: "ModelView",  # Special handling
            ViewType.COMPACT_CRUD_VIEW: "CompactCRUDMixin, ModelView",
            ViewType.CHART_VIEW: "BaseView",
            ViewType.FORM_VIEW: "BaseView",
            ViewType.CUSTOM_VIEW: "BaseView"
        }
        
        base_class = base_class_map.get(view_definition.view_type, "BaseView")
        view_class_name = f"{view_definition.name}View"
        
        # Generate imports based on components used
        imports = self._generate_imports(view_definition)
        
        # Generate custom methods
        custom_methods = {}
        for method_name, method_code in view_definition.custom_methods.items():
            custom_methods[method_name] = method_code
        
        # Add component-specific methods
        component_methods = self._generate_component_methods(view_definition)
        custom_methods.update(component_methods)
        
        # Related views for master-detail
        related_views = []
        if view_definition.view_type == ViewType.MASTER_DETAIL_VIEW:
            related_views = self._get_related_views(view_definition)
        
        context = {
            'app_name': 'app',  # TODO: Make configurable
            'view_class_name': view_class_name,
            'base_class': base_class,
            'model_name': view_definition.model_name,
            'base_permissions': view_definition.base_permissions,
            'list_columns': view_definition.list_columns,
            'show_columns': view_definition.show_columns,
            'add_columns': view_definition.add_columns,
            'edit_columns': view_definition.edit_columns,
            'search_columns': view_definition.search_columns,
            'custom_methods': custom_methods,
            'imports': imports,
            'view_type': view_definition.view_type.value,
            'related_views': related_views,
            'security_config': view_definition.security
        }
        
        return template.render(**context)
    
    def _generate_imports(self, view_definition: ViewDefinition) -> List[str]:
        """Generate necessary imports for the view."""
        imports = []
        
        # Component-specific imports
        component_imports = {
            ComponentType.CHART: "from flask_appbuilder.charts.views import ChartView",
            ComponentType.DATA_TABLE: "from flask_appbuilder.widgets import ListWidget",
            ComponentType.FILE_UPLOAD: "from flask_appbuilder.filemanager import ImageManager"
        }
        
        used_components = set()
        for component in view_definition.components.values():
            used_components.add(component.component_type)
        
        for comp_type in used_components:
            if comp_type in component_imports:
                imports.append(component_imports[comp_type])
        
        # Security imports
        if view_definition.security.required_permissions:
            imports.append("from flask_appbuilder.security.decorators import has_access")
        
        # API imports
        if view_definition.enable_api:
            imports.append("from flask_appbuilder.api import ModelRestApi")
        
        return list(set(imports))  # Remove duplicates
    
    def _generate_component_methods(self, view_definition: ViewDefinition) -> Dict[str, str]:
        """Generate methods based on components used in the view."""
        methods = {}
        
        for component in view_definition.components.values():
            if component.component_type == ComponentType.CHART:
                chart_method = self._generate_chart_method(component)
                if chart_method:
                    methods[f"chart_{component.component_id}"] = chart_method
            
            elif component.component_type == ComponentType.BUTTON:
                button_method = self._generate_button_method(component)
                if button_method:
                    methods[f"action_{component.component_id}"] = button_method
        
        return methods
    
    def _generate_chart_method(self, component: ComponentConfig) -> Optional[str]:
        """Generate method for chart components."""
        chart_type = component.properties.get('chart_type', 'line')
        
        return f"""
@expose('/chart_{component.component_id}')
def chart_{component.component_id}(self):
    \"\"\"Generate chart data for {component.label or component.component_id}.\"\"\"
    # TODO: Implement chart data logic
    data = {{
        'labels': ['Jan', 'Feb', 'Mar', 'Apr', 'May'],
        'datasets': [{{
            'label': '{component.label or 'Chart'}',
            'data': [10, 20, 30, 40, 50],
            'type': '{chart_type}'
        }}]
    }}
    return self.render_template('charts/chart.html', chart_data=data)
"""
    
    def _generate_button_method(self, component: ComponentConfig) -> Optional[str]:
        """Generate method for button components."""
        action_type = component.properties.get('action_type', 'custom')
        
        return f"""
@expose('/action_{component.component_id}')
@has_access
def action_{component.component_id}(self):
    \"\"\"Handle action for {component.label or component.component_id}.\"\"\"
    # TODO: Implement button action logic
    flash('{component.label or "Action"} executed successfully', 'success')
    return redirect(url_for('{{{{ self.__class__.__name__ }}}}.list'))
"""
    
    def _get_related_views(self, view_definition: ViewDefinition) -> List[str]:
        """Get related views for master-detail view."""
        # TODO: Implement based on relationships
        return []
    
    def _generate_html_template(self, view_definition: ViewDefinition) -> str:
        """Generate HTML template for the view."""
        template = Template(self.templates.HTML_TEMPLATE)
        
        # Generate component HTML
        component_html = self._generate_component_html(view_definition)
        
        # Generate custom CSS
        custom_css = self._generate_inline_css(view_definition)
        
        # Generate custom JavaScript
        custom_js = self._generate_inline_js(view_definition)
        
        context = {
            'view_title': view_definition.name.replace('_', ' ').title(),
            'view_type': 'custom' if view_definition.view_type == ViewType.CUSTOM_VIEW else 'standard',
            'component_html': component_html,
            'custom_css': custom_css,
            'custom_js': custom_js
        }
        
        return template.render(**context)
    
    def _generate_component_html(self, view_definition: ViewDefinition) -> str:
        """Generate HTML for all components in the view."""
        html_parts = []
        
        # Generate layout container
        if view_definition.layout.layout_type == "grid":
            html_parts.append('<div class="container-fluid">')
        
        # Generate root components
        for component_id in view_definition.root_components:
            component = view_definition.get_component(component_id)
            if component:
                component_html = self._generate_single_component_html(component, view_definition)
                html_parts.append(component_html)
        
        if view_definition.layout.layout_type == "grid":
            html_parts.append('</div>')
        
        return '\n'.join(html_parts)
    
    def _generate_single_component_html(self, component: ComponentConfig, 
                                      view_definition: ViewDefinition) -> str:
        """Generate HTML for a single component."""
        if not self.component_library:
            return f"<!-- Component {component.component_id} -->"
        
        template_code = self.component_library.get_component_template_code(component.component_type)
        if not template_code:
            return f"<!-- Unknown component type: {component.component_type} -->"
        
        try:
            # Create Jinja template from component template
            template = Template(template_code)
            
            # Prepare context for component rendering
            context = {
                'component_id': component.component_id,
                'name': component.component_id,
                'label': component.label,
                'placeholder': component.placeholder,
                'required': component.validation.required,
                'css_class': ' '.join(component.style.css_classes),
                'options': component.options,
                'children': []
            }
            
            # Add component-specific properties
            context.update(component.properties)
            
            # Add position-based CSS classes for grid layout
            if view_definition.layout.layout_type == "grid" and component.position.row is not None:
                grid_classes = []
                if component.position.column is not None:
                    grid_classes.append(f"col-{component.position.span}")
                if component.position.row == 0:
                    grid_classes.append("mt-0")
                
                context['css_class'] += ' ' + ' '.join(grid_classes)
            
            # Generate children HTML
            children_html = []
            for child_id in component.children:
                child_component = view_definition.get_component(child_id)
                if child_component:
                    child_html = self._generate_single_component_html(child_component, view_definition)
                    children_html.append(child_html)
            
            context['children'] = children_html
            
            return template.render(**context)
            
        except Exception as e:
            logger.error(f"Failed to generate HTML for component {component.component_id}: {e}")
            return f"<!-- Error generating component {component.component_id}: {e} -->"
    
    def _generate_inline_css(self, view_definition: ViewDefinition) -> str:
        """Generate inline CSS for the view."""
        css_parts = []
        
        for component in view_definition.components.values():
            if component.style.custom_css:
                css_parts.append(f"#{component.component_id} {{")
                for prop, value in component.style.custom_css.items():
                    css_parts.append(f"  {prop}: {value};")
                css_parts.append("}")
        
        return '\n'.join(css_parts)
    
    def _generate_inline_js(self, view_definition: ViewDefinition) -> str:
        """Generate inline JavaScript for the view."""
        js_parts = []
        
        # Add event handlers
        for component in view_definition.components.values():
            if component.events:
                for event, handler in component.events.items():
                    js_parts.append(f"""
document.getElementById('{component.component_id}').addEventListener('{event.lower().replace('on', '')}', function() {{
    {handler}
}});""")
        
        if js_parts:
            js_parts.insert(0, "document.addEventListener('DOMContentLoaded', function() {")
            js_parts.append("});")
        
        return '\n'.join(js_parts)
    
    def _generate_css_styles(self, view_definition: ViewDefinition) -> Optional[str]:
        """Generate external CSS file for the view."""
        css_rules = []
        
        for component in view_definition.components.values():
            if component.style.custom_css:
                css_rules.append(f"#{component.component_id} {{")
                for prop, value in component.style.custom_css.items():
                    css_rules.append(f"  {prop}: {value};")
                css_rules.append("}")
                css_rules.append("")
        
        return '\n'.join(css_rules) if css_rules else None
    
    def _generate_javascript(self, view_definition: ViewDefinition) -> Optional[str]:
        """Generate external JavaScript file for the view."""
        js_code = []
        
        # Component interactions
        interactive_components = [comp for comp in view_definition.components.values() 
                                if comp.events or comp.component_type in [ComponentType.CHART, ComponentType.BUTTON]]
        
        if not interactive_components:
            return None
        
        js_code.append("// Auto-generated JavaScript for view: " + view_definition.name)
        js_code.append("document.addEventListener('DOMContentLoaded', function() {")
        
        for component in interactive_components:
            if component.component_type == ComponentType.CHART:
                js_code.extend(self._generate_chart_js(component))
            elif component.component_type == ComponentType.BUTTON:
                js_code.extend(self._generate_button_js(component))
            
            # Add event handlers
            for event, handler in component.events.items():
                event_name = event.lower().replace('on', '')
                js_code.append(f"  document.getElementById('{component.component_id}').addEventListener('{event_name}', {handler});")
        
        js_code.append("});")
        return '\n'.join(js_code)
    
    def _generate_chart_js(self, component: ComponentConfig) -> List[str]:
        """Generate JavaScript for chart components."""
        chart_type = component.properties.get('chart_type', 'line')
        
        return [
            f"  // Chart setup for {component.component_id}",
            f"  const ctx_{component.component_id} = document.getElementById('{component.component_id}').getContext('2d');",
            f"  const chart_{component.component_id} = new Chart(ctx_{component.component_id}, {{",
            f"    type: '{chart_type}',",
            f"    data: {{",
            f"      // TODO: Load chart data",
            f"    }},",
            f"    options: {{",
            f"      responsive: true,",
            f"      maintainAspectRatio: false",
            f"    }}",
            f"  }});",
            ""
        ]
    
    def _generate_button_js(self, component: ComponentConfig) -> List[str]:
        """Generate JavaScript for button components."""
        return [
            f"  // Button handler for {component.component_id}",
            f"  document.getElementById('{component.component_id}').addEventListener('click', function() {{",
            f"    // TODO: Implement button action",
            f"    console.log('Button {component.component_id} clicked');",
            f"  }});",
            ""
        ]
    
    def generate_model_code(self, model_name: str, fields: List[Dict[str, Any]], 
                          relationships: List[Dict[str, Any]] = None) -> str:
        """Generate model code for a data model."""
        template = Template(self.templates.MODEL_TEMPLATE)
        
        context = {
            'model_class_name': model_name,
            'model_name': model_name.lower(),
            'table_name': model_name.lower() + 's',
            'fields': fields,
            'relationships': relationships or [],
            'str_repr_field': fields[0]['name'] if fields else 'id',
            'imports': []
        }
        
        return template.render(**context)
    
    def generate_application_structure(self, project: IDEProject) -> Dict[str, str]:
        """Generate complete application structure files."""
        files = {}
        
        # Generate __init__.py
        init_code = self._generate_init_file(project)
        files['__init__.py'] = init_code
        
        # Generate views __init__.py
        views_init = self._generate_views_init(project)
        files['views/__init__.py'] = views_init
        
        # Generate models __init__.py
        models_init = self._generate_models_init(project)
        files['models/__init__.py'] = models_init
        
        # Generate run.py
        run_code = self._generate_run_file(project)
        files['run.py'] = run_code
        
        return files
    
    def _generate_init_file(self, project: IDEProject) -> str:
        """Generate main __init__.py file."""
        template = Template(self.templates.INIT_TEMPLATE)
        
        view_imports = []
        view_registrations = []
        model_imports = []
        
        for view_name, view_def in project.views.items():
            # View imports
            view_class = f"{view_name}View"
            view_imports.append(f"from .views.{view_name.lower()}_view import {view_class}")
            
            # View registrations
            if view_def.model_name:
                view_registrations.append(f"appbuilder.add_view({view_class}, '{view_name}', category='{view_def.tags[0] if view_def.tags else 'General'}')")
            else:
                view_registrations.append(f"appbuilder.add_view({view_class}, '{view_name}', href='/view/{view_name.lower()}/', category='{view_def.tags[0] if view_def.tags else 'General'}')")
            
            # Model imports
            if view_def.model_name:
                model_imports.append(f"from .models.{view_def.model_name.lower()} import {view_def.model_name}")
        
        context = {
            'view_imports': view_imports,
            'view_registrations': view_registrations,
            'model_imports': list(set(model_imports))  # Remove duplicates
        }
        
        return template.render(**context)
    
    def _generate_views_init(self, project: IDEProject) -> str:
        """Generate views/__init__.py file."""
        imports = []
        for view_name in project.views.keys():
            view_class = f"{view_name}View"
            imports.append(f"from .{view_name.lower()}_view import {view_class}")
        
        return '\n'.join(imports)
    
    def _generate_models_init(self, project: IDEProject) -> str:
        """Generate models/__init__.py file."""
        imports = []
        model_names = set()
        
        for view_def in project.views.values():
            if view_def.model_name and view_def.model_name not in model_names:
                imports.append(f"from .{view_def.model_name.lower()} import {view_def.model_name}")
                model_names.add(view_def.model_name)
        
        return '\n'.join(imports)
    
    def _generate_run_file(self, project: IDEProject) -> str:
        """Generate run.py file."""
        return """
from app import app

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
"""
    
    def generate_configuration_files(self, project: IDEProject) -> Dict[str, str]:
        """Generate configuration files for the project."""
        files = {}
        
        # Generate config.py
        config_code = self._generate_config_file(project)
        files['config.py'] = config_code
        
        # Generate requirements.txt
        requirements = self._generate_requirements_file(project)
        files['requirements.txt'] = requirements
        
        # Generate .env template
        env_template = self._generate_env_template(project)
        files['.env.template'] = env_template
        
        return files
    
    def _generate_config_file(self, project: IDEProject) -> str:
        """Generate config.py file."""
        template = Template(self.templates.CONFIG_TEMPLATE)
        
        context = {
            'secret_key': 'your-secret-key-here',  # TODO: Generate random key
            'database_uri': project.database_config.get('uri', 'sqlite:///app.db'),
            'app_name': project.name,
            'theme': project.flask_config.get('theme'),
            'app_icon': project.flask_config.get('app_icon'),
            'auth_type': project.security_config.get('auth_type'),
            'admin_role': project.security_config.get('admin_role'),
            'public_role': project.security_config.get('public_role'),
            'log_level': project.flask_config.get('log_level'),
            'additional_config': project.flask_config
        }
        
        return template.render(**context)
    
    def _generate_requirements_file(self, project: IDEProject) -> str:
        """Generate requirements.txt file."""
        base_requirements = [
            'Flask>=2.0.0',
            'Flask-AppBuilder>=4.0.0',
            'Flask-SQLAlchemy>=3.0.0',
            'SQLAlchemy>=2.0.0'
        ]
        
        # Add requirements based on components used
        additional_requirements = set()
        
        for view_def in project.views.values():
            for component in view_def.components.values():
                if component.component_type == ComponentType.CHART:
                    additional_requirements.add('matplotlib>=3.5.0')
                    additional_requirements.add('plotly>=5.0.0')
                elif component.component_type == ComponentType.FILE_UPLOAD:
                    additional_requirements.add('Pillow>=8.0.0')
        
        all_requirements = base_requirements + list(additional_requirements)
        return '\n'.join(sorted(all_requirements))
    
    def _generate_env_template(self, project: IDEProject) -> str:
        """Generate .env template file."""
        return """
# Flask Configuration
SECRET_KEY=your-secret-key-here
FLASK_ENV=development
FLASK_DEBUG=1

# Database Configuration
DATABASE_URL=sqlite:///app.db

# Flask-AppBuilder Configuration
APP_NAME={app_name}
AUTH_TYPE=AUTH_DB

# Additional Configuration
# Add your custom environment variables here
""".format(app_name=project.name)
    
    # Utility methods
    def _requires_custom_template(self, view_definition: ViewDefinition) -> bool:
        """Check if view requires a custom HTML template."""
        return (view_definition.view_type == ViewType.CUSTOM_VIEW or
                any(comp.component_type in [ComponentType.CHART, ComponentType.CARD] 
                    for comp in view_definition.components.values()))
    
    def _determine_file_type(self, file_path: str) -> str:
        """Determine the type of file based on path."""
        if 'view' in file_path and file_path.endswith('.py'):
            return 'view'
        elif 'model' in file_path and file_path.endswith('.py'):
            return 'model'
        elif file_path.endswith('.html'):
            return 'template'
        elif file_path.endswith('.py'):
            return 'config'
        elif file_path.endswith(('.css', '.js', '.jpg', '.png')):
            return 'static'
        else:
            return 'other'
    
    def _determine_language(self, file_path: str) -> str:
        """Determine the programming language of a file."""
        if file_path.endswith('.py'):
            return 'python'
        elif file_path.endswith('.html'):
            return 'html'
        elif file_path.endswith('.css'):
            return 'css'
        elif file_path.endswith('.js'):
            return 'javascript'
        else:
            return 'text'
    
    def write_files_to_disk(self) -> bool:
        """Write all generated files to disk."""
        try:
            for file_path, generated_file in self.generated_files.items():
                full_path = self.output_path / file_path
                full_path.parent.mkdir(parents=True, exist_ok=True)
                
                with open(full_path, 'w', encoding='utf-8') as f:
                    f.write(generated_file.content)
            
            logger.info(f"Wrote {len(self.generated_files)} files to disk")
            return True
            
        except Exception as e:
            logger.error(f"Failed to write files to disk: {e}")
            return False
    
    def get_generated_files(self) -> Dict[str, GeneratedFile]:
        """Get all generated files."""
        return self.generated_files.copy()
    
    def clear_generated_files(self):
        """Clear all generated files from memory."""
        self.generated_files.clear()
        logger.info("Cleared generated files from memory")